#solution0001 两数之和 two-sum Easy 
    给定一个整数数组 nums 和一个目标值 target,请你在该数组中找出和为目标值的那两个整数,并返回他们的数组下标.
    你可以假设每种输入只会对应一个答案.但是,你不能重复利用这个数组中同样的元素.
#solution0002 两数相加 add-two-numbers Medium
    给出两个非空的链表用来表示两个非负的整数.其中,它们各自的位数是按照逆序的方式存储的,并且它们的每个节点只能存储一位数字.
    如果,我们将这两个数相加起来,则会返回一个新的链表来表示它们的和.
    您可以假设除了数字0之外,这两个数都不会以0开头.
#solution0003 无重复字符的最长子串 longest-substring-without-repeating-characters Medium
    给定一个字符串,请你找出其中不含有重复字符的最长子串的长度.
#solution0004 寻找两个有序数组的中位数 median-of-two-sorted-arrays Hard
    给定两个大小为 m 和 n 的有序数组 nums1 和 nums2.
    请你找出这两个有序数组的中位数,并且要求算法的时间复杂度为 O(log(m + n)).
    你可以假设 nums1 和 nums2 不会同时为空.
#solution0005 最长回文子串 longest-palindromic-substring Medium
    给定一个字符串 s,找到 s 中最长的回文子串.你可以假设 s 的最大长度为 1000.
#solution0007 整数反转 reverse-integer Easy
    给出一个 32 位的有符号整数,你需要将这个整数中每位上的数字进行反转.
#solution0009  回文数 palindrome-number Easy
    判断一个整数是否是回文数.回文数是指正序(从左向右)和倒序(从右向左)读都是一样的整数.
#solution0015 三数之和 3sum Medium
    给定一个包含 n 个整数的数组 nums,判断 nums 中是否存在三个元素 a,b,c ,使得 a + b + c = 0?找出所有满足条件且不重复的三元组.
    注意: 答案中不可以包含重复的三元组.
#solution0017 电话号码的字母组合 letter-combinations-of-a-phone-number Medium
    给定一个仅包含数字 2-9 的字符串,返回所有它能表示的字母组合.
    给出数字到字母的映射如下(与电话按键相同).注意 1 不对应任何字母.
#solution0046 全排列 permutations Medium
    给定一个没有重复数字的序列,返回其所有可能的全排列.
#solution0049 字母异位词分组 group-anagrams Medium
    给定一个字符串数组,将字母异位词组合在一起.字母异位词指字母相同,但排列不同的字符串.
#solution0055 跳跃游戏 jump-game Medium
    给定一个非负整数数组,你最初位于数组的第一个位置.
    数组中的每个元素代表你在该位置可以跳跃的最大长度.
    判断你是否能够到达最后一个位置.
#solution0070 爬楼梯 climbing-stairs Easy
    假设你正在爬楼梯.需要 n 阶你才能到达楼顶.
    每次你可以爬 1 或 2 个台阶.你有多少种不同的方法可以爬到楼顶呢?
    注意:给定 n 是一个正整数.
#solution0083 删除排序链表中的重复元素 remove-duplicates-from-sorted-list Easy
    给定一个排序链表,删除所有重复的元素,使得每个元素只出现一次.
#solution0168  Excel表列名称 excel-sheet-column-title Easy
    给定一个正整数,返回它在 Excel 表中相对应的列名称.
#solution0169 多数元素 majority-element Easy
    给定一个大小为 n 的数组,找到其中的多数元素.多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素.
    你可以假设数组是非空的,并且给定的数组总是存在多数元素.
#solution0175 组合两个表 combine-two-tables Easy @SQL
    编写一个 SQL 查询,满足条件: 无论 person 是否有地址信息,都需要基于上述两表提供 person 的以下信息: 
#solution0176 第二高的薪水 second-highest-salary Easy @SQL
    例如上述 Employee 表,SQL查询应该返回 200 作为第二高的薪水.如果不存在第二高的薪水,那么查询应返回 null.
#solution0177 第N高的薪水 nth-highest-salary Medium @SQL
    例如上述 Employee 表,n = 2 时,应返回第二高的薪水 200.如果不存在第 n 高的薪水,那么查询应返回 null.
#solution0178 分数排名 rank-scores Medium @SQL
    编写一个 SQL 查询来实现分数排名.如果两个分数相同,则两个分数排名(Rank)相同.请注意,平分后的下一个名次应该是下一个连续的整数值.换句话说,名次之间不应该有“间隔”.
#solution0180 连续出现的数字 consecutive-numbers Medium @SQL
    编写一个 SQL 查询,查找所有至少连续出现三次的数字.
#solution0181 超过经理收入的员工 employees-earning-more-than-their-managers Easy @SQL
    Employee 表包含所有员工,他们的经理也属于员工.每个员工都有一个 Id,此外还有一列对应员工的经理的 Id.
#solution0182 查找重复的电子邮箱 duplicate-emails Easy @SQL
    编写一个 SQL 查询,查找 Person 表中所有重复的电子邮箱.
#solution0183 从不订购的客户 customers-who-never-order Easy @SQL
    某网站包含两个表,Customers 表和 Orders 表.编写一个 SQL 查询,找出所有从不订购任何东西的客户.
#solution0184 部门工资最高的员工 department-highest-salary Medium @SQL
    编写一个 SQL 查询,找出每个部门工资最高的员工.例如,根据上述给定的表格,Max 在 IT 部门有最高工资,Henry 在 Sales 部门有最高工资
#solution0185 部门工资前三高的所有员工 department-top-three-salaries Hard @SQL
    编写一个 SQL 查询,找出每个部门获得前三高工资的所有员工.例如,根据上述给定的表,查询结果应返回: 
#solution0196 删除重复的电子邮箱 delete-duplicate-emails Easy @SQL
    编写一个 SQL 查询,来删除 Person 表中所有重复的电子邮箱,重复的邮箱里只保留 Id 最小 的那个.
#solution0197 上升的温度 rising-temperature Easy @SQL
    给定一个 Weather 表,编写一个 SQL 查询,来查找与之前(昨天的)日期相比温度更高的所有日期的 Id.
#solution0198 打家劫舍 house-robber Easy
    你是一个专业的小偷,计划偷窃沿街的房屋.每间房内都藏有一定的现金,影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统,如果两间相邻的房屋在同一晚上被小偷闯入,系统会自动报警.
    给定一个代表每个房屋存放金额的非负整数数组,计算你在不触动警报装置的情况下,能够偷窃到的最高金额.
#solution0200 岛屿数量 number-of-islands Medium
    给定一个由 '1'(陆地)和 '0'(水)组成的的二维网格,计算岛屿的数量.一个岛被水包围,并且它是通过水平方向或垂直方向上相邻的陆地连接而成的.你可以假设网格的四个边均被水包围.
#solution0213 打家劫舍 II house-robber-ii Medium
    你是一个专业的小偷,计划偷窃沿街的房屋,每间房内都藏有一定的现金.这个地方所有的房屋都围成一圈,这意味着第一个房屋和最后一个房屋是紧挨着的.
    同时,相邻的房屋装有相互连通的防盗系统,如果两间相邻的房屋在同一晚上被小偷闯入,系统会自动报警.
    给定一个代表每个房屋存放金额的非负整数数组,计算你在不触动警报装置的情况下,能够偷窃到的最高金额.
#solution0214 最短回文串 shortest-palindrome Hard
    给定一个字符串 s, 你可以通过在字符串前面添加字符将其转换为回文串. 找到并返回可以用这种方式转换的最短回文串. 
#solution0223 矩形面积 rectangle-area Medium
    在二维平面上计算出两个由直线构成的矩形重叠后形成的总面积.
    每个矩形由其左下顶点和右上顶点坐标表示,如图所示.
#solution0227 基本计算器 II basic-calculator-ii Medium
    实现一个基本的计算器来计算一个简单的字符串表达式的值.
    字符串表达式仅包含非负整数,+, - ,*,/ 四种运算符和空格  . 整数除法仅保留整数部分.
#solution0262 行程和用户 trips-and-users Hard @SQL
    写一段 SQL 语句查出 2013年10月1日 至 2013年10月3日 期间非禁止用户的取消率.基于上表,你的 SQL 语句应返回如下结果,取消率(Cancellation Rate)保留两位小数.
    取消率的计算方式如下: (被司机或乘客取消的非禁止用户生成的订单数量) / (非禁止用户生成的订单总数)
#solution0279 完全平方数 perfect-squares Medium
    给定正整数 n,找到若干个完全平方数(比如 1, 4, 9, 16, ...)使得它们的和等于 n.你需要让组成和的完全平方数的个数最少.
#solution0300 最长上升子序列 longest-increasing-subsequence Medium
    给定一个无序的整数数组,找到其中最长上升子序列的长度.
#solution0329 矩阵中的最长递增路径 longest-increasing-path-in-a-matrix Hard
    给定一个整数矩阵,找出最长递增路径的长度.
    对于每个单元格,你可以往上,下,左,右四个方向移动. 你不能在对角线方向上移动或移动到边界外(即不允许环绕).
#solution0365 水壶问题 water-and-jug-problem Medium
    有两个容量分别为 x升 和 y升 的水壶以及无限多的水.请判断能否通过使用这两个水壶,从而可以得到恰好 z升 的水?
    如果可以,最后请用以上水壶中的一或两个来盛放取得的 z升 水.
    你允许: 
    装满任意一个水壶
    清空任意一个水壶
    从一个水壶向另外一个水壶倒水,直到装满或者倒空
#solution0368 最大整除子集 largest-divisible-subset Medium
    给出一个由无重复的正整数组成的集合,找出其中最大的整除子集,子集中任意一对 (Si,Sj) 都要满足: Si % Sj = 0 或 Sj % Si = 0.
    如果有多个目标子集,返回其中任何一个均可.
#solution0407 接雨水 II trapping-rain-water-ii Hard
    给定一个 m x n 的矩阵,其中的值均为正整数,代表二维高度图每个单元的高度,请计算图中形状最多能接多少体积的雨水.
#solution0409 最长回文串 longest-palindrome Easy
    给定一个包含大写字母和小写字母的字符串,找到通过这些字母构造成的最长的回文串.
    在构造过程中,请注意区分大小写.比如 "Aa" 不能当做一个回文字符串.
    注意:假设字符串的长度不会超过 1010.
#solution0419 甲板上的战舰 battleships-in-a-board Medium
    给定一个二维的甲板, 请计算其中有多少艘战舰. 战舰用 'X'表示,空位用 '.'表示. 你需要遵守以下规则:
    给你一个有效的甲板,仅由战舰或者空位组成.
    战舰只能水平或者垂直放置.换句话说,战舰只能由 1xN (1 行, N 列)组成,或者 Nx1 (N 行, 1 列)组成,其中N可以是任意大小.
    两艘战舰之间至少有一个水平或垂直的空位分隔 - 即没有相邻的战舰.
#solution0595 大的国家 big-countries Easy @SQL
    如果一个国家的面积超过300万平方公里,或者人口超过2500万,那么这个国家就是大国家.
    编写一个SQL查询,输出表中所有大国家的名称、人口和面积.
#solution0596 超过5名学生的课 classes-more-than-5-students Easy @SQL
    请列出所有超过或等于5名学生的课.
#solution0601 体育馆的人流量 human-traffic-of-stadium Hard @SQL
    X 市建了一个新的体育馆,每日人流量信息被记录在这三列信息中: 序号 (id)、日期 (visit_date)、 人流量 (people).
    请编写一个查询语句,找出人流量的高峰期.高峰期时,至少连续三行记录中的人流量不少于100.
#solution0620 有趣的电影 not-boring-movies Easy @SQL
    某城市开了一家新的电影院,吸引了很多人过来看电影.该电影院特别注意用户体验,专门有个 LED显示板做电影推荐,上面公布着影评和相关电影描述.
    作为该电影院的信息部主管,您需要编写一个 SQL查询,找出所有影片描述为非 boring (不无聊) 的并且 id 为奇数 的影片,结果请按等级 rating 排列.
#solution0626 换座位 exchange-seats Medium @SQL
    小美是一所中学的信息科技老师,她有一张 seat 座位表,平时用来储存学生名字和与他们相对应的座位 id.
    其中纵列的 id 是连续递增的
    小美想改变相邻俩学生的座位.
    你能不能帮她写一个 SQL query 来输出小美想要的结果呢?
#solution0627 交换工资 swap-salary Easy @SQL
    给定一个 salary 表,如下所示,有 m = 男性 和 f = 女性 的值.交换所有的 f 和 m 值(例如,将所有 f 值更改为 m,反之亦然).要求只使用一个更新(Update)语句,并且没有中间的临时表.
    注意,您必只能写一个 Update 语句,请不要编写任何 Select 语句.
#solution0673 最长递增子序列的个数 number-of-longest-increasing-subsequence Medium
    给定一个未排序的整数数组,找到最长递增子序列的个数.
#solution0677 键值映射 map-sum-pairs Medium
    实现一个 MapSum 类里的两个方法,insert 和 sum.
    对于方法 insert,你将得到一对(字符串,整数)的键值对.字符串表示键,整数表示值.如果键已经存在,那么原来的键值对将被替代成新的键值对.
    对于方法 sum,你将得到一个表示前缀的字符串,你需要返回所有以该前缀开头的键的值的总和.
#solution0695 岛屿的最大面积 max-area-of-island Medium
    给定一个包含了一些 0 和 1的非空二维数组 grid , 一个 岛屿 是由四个方向 (水平或垂直) 的 1 (代表土地) 构成的组合.你可以假设二维矩阵的四个边缘都被水包围着.
    找到给定的二维数组中最大的岛屿面积.(如果没有岛屿,则返回面积为0.)
#solution0828 统计子串中的唯一字符 count-unique-characters-of-all-substrings-of-a-given-string Hard
    我们定义了一个函数 countUniqueChars(s) 来统计字符串 s 中的唯一字符,并返回唯一字符的个数.
    例如: s = "LEETCODE" ,则其中 "L", "T","C","O","D" 都是唯一字符,因为它们只出现一次,所以 countUniqueChars(s) = 5 .
    本题将会给你一个字符串 s ,我们需要返回 countUniqueChars(t) 的总和,其中 t 是 s 的子字符串.注意,某些子字符串可能是重复的,
    但你统计时也必须算上这些重复的子字符串(也就是说,你必须统计 s 的所有子字符串中的唯一字符).
    由于答案可能非常大,请将结果 mod 10 ^ 9 + 7 后再返回.
#solution0829 连续整数求和 consecutive-numbers-sum Hard
    给定一个正整数 N,试求有多少组连续正整数满足所有数字之和为 N?
#solution0830 较大分组的位置 positions-of-large-groups Easy
    在一个由小写字母构成的字符串 S 中,包含由一些连续的相同字符所构成的分组.
    例如,在字符串 S = "abbxxxxzyy" 中,就含有 "a", "bb", "xxxx", "z" 和 "yy" 这样的一些分组.
    我们称所有包含大于或等于三个连续字符的分组为较大分组.找到每一个较大分组的起始和终止位置.
    最终结果按照字典顺序输出.
#solution0831 隐藏个人信息 masking-personal-information Medium
    给你一条个人信息 string S,它可能是一个邮箱地址,也可能是一个电话号码.
    我们将隐藏它的隐私信息,通过如下规则:
    <u>1. 电子邮箱</u>
    定义名称 <name> 是长度大于等于 2 (length ≥ 2),并且只包含小写字母 a-z 和大写字母 A-Z 的字符串.
    电子邮箱地址由名称 <name> 开头,紧接着是符号 <font face="Menlo, Monaco, Consolas, Courier New, monospace">'@'</font>,后面接着一个名称 <name>,再接着一个点号 '.',然后是一个名称 <name>.
    电子邮箱地址确定为有效的,并且格式是 "name1@name2.name3".
    为了隐藏电子邮箱,所有的名称 <name> 必须被转换成小写的,并且第一个名称 <name> 的第一个字母和最后一个字母的中间的所有字母由 5 个 '*' 代替.
    <u>2. 电话号码</u>
    电话号码是一串包括数字 0-9,以及 {'+', '-', '(', ')', ' '} 这几个字符的字符串.你可以假设电话号码包含 10 到 13 个数字.
    电话号码的最后 10 个数字组成本地号码,在这之前的数字组成国际号码.注意,国际号码是可选的.我们只暴露最后 4 个数字并隐藏所有其他数字.
    本地号码是有格式的,并且如 "***-***-1111" 这样显示,这里的 1 表示暴露的数字.
    为了隐藏有国际号码的电话号码,像 "+111 111 111 1111",我们以 "+***-***-***-1111" 的格式来显示.在本地号码前面的 '+' 号和第一个 '-' 号仅当电话号码中包含国际号码时存在.
    例如,一个 12 位的电话号码应当以 "+**-" 开头进行显示.
    注意: 像 "(",")"," " 这样的不相干的字符以及不符合上述格式的额外的减号或者加号都应当被删除.
    最后,将提供的信息正确隐藏后返回.
#solution0836 矩形重叠 rectangle-overlap Easy
    矩形以列表 [x1, y1, x2, y2] 的形式表示,其中 (x1, y1) 为左下角的坐标,(x2, y2) 是右上角的坐标. 
    如果相交的面积为正,则称两矩形重叠.需要明确的是,只在角或边接触的两个矩形不构成重叠.
    给出两个矩形,判断它们是否重叠并返回结果.
#solution0860 柠檬水找零 lemonade-change Easy
    在柠檬水摊上,每一杯柠檬水的售价为 5 美元.
    顾客排队购买你的产品,(按账单 bills 支付的顺序)一次购买一杯.
    每位顾客只买一杯柠檬水,然后向你付 5 美元,10 美元或 20 美元.你必须给每个顾客正确找零,也就是说净交易是每位顾客向你支付 5 美元.
    注意,一开始你手头没有任何零钱.
    如果你能给每位顾客正确找零,返回 true ,否则返回 false .
#solution0865 具有所有最深结点的最小子树 smallest-subtree-with-all-the-deepest-nodes Medium
    给定一个根为 root 的二叉树,每个结点的深度是它到根的最短距离.
    如果一个结点在整个树的任意结点之间具有最大的深度,则该结点是最深的.
    一个结点的子树是该结点加上它的所有后代的集合.
    返回能满足"以该结点为根的子树中包含所有最深的结点"这一条件的具有最大深度的结点.
#solution0876 链表的中间结点 middle-of-the-linked-list Easy
    给定一个带有头结点 head 的非空单链表,返回链表的中间结点.
    如果有两个中间结点,则返回第二个中间结点.
#solution0945 使数组唯一的最小增量 minimum-increment-to-make-array-unique Medium
    给定整数数组 A,每次 move 操作将会选择任意 A[i],并将其递增 1.
    返回使 A 中的每个值都是唯一的最少操作次数.
#solution0991 坏了的计算器 broken-calculator Medium
    在显示着数字的坏计算器上,我们可以执行以下两种操作: 
    双倍(Double): 将显示屏上的数字乘 2；
    递减(Decrement): 将显示屏上的数字减 1 .
    最初,计算器显示数字 X.
    返回显示数字 Y 所需的最小操作数.
#solution1052 爱生气的书店老板 grumpy-bookstore-owner Medium
    今天,书店老板有一家店打算试营业 customers.length 分钟.每分钟都有一些顾客(customers[i])会进入书店,所有这些顾客都会在那一分钟结束后离开.
    在某些时候,书店老板会生气. 如果书店老板在第 i 分钟生气,那么 grumpy[i] = 1,否则 grumpy[i] = 0. 当书店老板生气时,那一分钟的顾客就会不满意,不生气则他们是满意的.
    书店老板知道一个秘密技巧,能抑制自己的情绪,可以让自己连续 X 分钟不生气,但却只能使用一次.
    请你返回这一天营业下来,最多有多少客户能够感到满意的数量.
#solution1071 字符串的最大公因子 greatest-common-divisor-of-strings Easy
    对于字符串 S 和 T,只有在 S = T + ... + T(T 与自身连接 1 次或多次)时,我们才认定 "T 能除尽 S".
    返回最长字符串 X,要求满足 X 能除尽 str1 且 X 能除尽 str2.
#solution1155 掷骰子的N种方法 number-of-dice-rolls-with-target-sum Medium
    这里有 d 个一样的骰子,每个骰子上都有 f 个面,分别标号为 1, 2, ..., f.
    我们约定: 掷骰子的得到总点数为各骰子面朝上的数字的总和.
    如果需要掷出的总点数为 target,请你计算出有多少种不同的组合情况(所有的组合情况总共有 f^d 种),模 10^9 + 7 后返回.
#solution1160 拼写单词 find-words-that-can-be-formed-by-characters Easy
    给你一份『词汇表』(字符串数组) words 和一张『字母表』(字符串) chars.
    假如你可以用 chars 中的『字母』(字符)拼写出 words 中的某个『单词』(字符串),那么我们就认为你掌握了这个单词.
    注意: 每次拼写时,chars 中的每个字母都只能用一次.
    返回词汇表 words 中你掌握的所有单词的 长度之和.
#solution1179 重新格式化部门表 reformat-department-table Easy
    编写一个 SQL 查询来重新格式化表,使得新的表中有一个部门 id 列和一些对应 每个月 的收入(revenue)列.
#solution1269 停在原地的方案数 number-of-ways-to-stay-in-the-same-place-after-some-steps Hard
    有一个长度为 arrLen 的数组,开始有一个指针在索引 0 处.
    每一步操作中,你可以将指针向左或向右移动 1 步,或者停在原地(指针不能被移动到数组范围外).
    给你两个整数 steps 和 arrLen ,请你计算并返回: 在恰好执行 steps 次操作以后,指针仍然指向索引 0 处的方案数.
    由于答案可能会很大,请返回方案数 模 10^9 + 7 后的结果.
#solution1306 跳跃游戏 III jump-game-iii Medium
    这里有一个非负整数数组 arr,你最开始位于该数组的起始下标 start 处.当你位于下标 i 处时,你可以跳到 i + arr[i] 或者 i - arr[i].
    请你判断自己是否能够跳到对应元素值为 0 的 任意 下标处.
    注意,不管是什么情况下,你都无法跳到数组之外.
#solution1380 矩阵中的幸运数 lucky-numbers-in-a-matrix Easy
    给你一个 m * n 的矩阵,矩阵中的数字 各不相同 .请你按 任意 顺序返回矩阵中的所有幸运数.
    幸运数是指矩阵中满足同时下列两个条件的元素:
    在同一行的所有元素中最小
    在同一列的所有元素中最大
#solution1381 设计一个支持增量操作的栈 design-a-stack-with-increment-operation Medium
    请你设计一个支持下述操作的栈.
    实现自定义栈类 CustomStack :
    CustomStack(int maxSize):用 maxSize 初始化对象,maxSize 是栈中最多能容纳的元素数量,栈在增长到 maxSize 之后则不支持 push 操作.
    void push(int x):如果栈还未增长到 maxSize ,就将 x 添加到栈顶.
    int pop():返回栈顶的值,或栈为空时返回 -1 .
    void inc(int k, int val):栈底的 k 个元素的值都增加 val .如果栈中元素总数小于 k ,则栈中的所有元素都增加 val .
#solution1382 将二叉搜索树变平衡 balance-a-binary-search-tree Medium
    给你一棵二叉搜索树,请你返回一棵 平衡后 的二叉搜索树,新生成的树应该与原来的树有着相同的节点值.
    如果一棵二叉搜索树中,每个节点的两棵子树高度差不超过 1 ,我们就称这棵二叉搜索树是 平衡的 .
    如果有多种构造方法,请你返回任意一种.
#solution1383 最大的团队表现值 maximum-performance-of-a-team Hard
    公司有编号为 1 到 n 的 n 个工程师,给你两个数组 speed 和 efficiency ,其中 speed[i] 和 efficiency[i] 分别代表第 i 位工程师的速度和效率.
    请你返回由最多 k 个工程师组成的最大团队表现值 ,由于答案可能很大,请你返回结果对 10^9 + 7 取余后的结果.
    团队表现值 的定义为:一个团队中「所有工程师速度的和」乘以他们「效率值中的最小值」.
#solution1385 两个数组间的距离值 find-the-distance-value-between-two-arrays Easy
    给你两个整数数组 arr1 , arr2 和一个整数 d ,请你返回两个数组之间的 距离值 .
    「距离值」 定义为符合此描述的元素数目: 对于元素 arr1[i] ,不存在任何元素 arr2[j] 满足 |arr1[i]-arr2[j]| <= d .
#solution1386 安排电影院座位 cinema-seat-allocation Medium
    如上图所示,电影院的观影厅中有 n 行座位,行编号从 1 到 n ,且每一行内总共有 10 个座位,列编号从 1 到 10 .
    给你数组 reservedSeats ,包含所有已经被预约了的座位.比如说,researvedSeats[i]=[3,8] ,它表示第 3 行第 8 个座位被预约了.
    请你返回 最多能安排多少个 4 人家庭 .4 人家庭要占据 同一行内连续 的 4 个座位.隔着过道的座位(比方说 [3,3] 和 [3,4])不是连续的座位,
    但是如果你可以将 4 人家庭拆成过道两边各坐 2 人,这样子是允许的.
#solution1387 将整数按权重排序 sort-integers-by-the-power-value Medium
    我们将整数 x 的 权重 定义为按照下述规则将 x 变成 1 所需要的步数: 
    如果 x 是偶数,那么 x = x / 2
    如果 x 是奇数,那么 x = 3 * x + 1
    比方说,x=3 的权重为 7 .因为 3 需要 7 步变成 1 (3 --> 10 --> 5 --> 16 --> 8 --> 4 --> 2 --> 1).
    给你三个整数 lo, hi 和 k .你的任务是将区间 [lo, hi] 之间的整数按照它们的权重 升序排序 ,如果大于等于 2 个整数有 相同 的权重,那么按照数字自身的数值 升序排序 .
    请你返回区间 [lo, hi] 之间的整数按权重排序后的第 k 个数.
    注意,题目保证对于任意整数 x (lo <= x <= hi) ,它变成 1 所需要的步数是一个 32 位有符号整数.
#solution1388 3n块披萨 pizza-with-3n-slices Hard
    给你一个披萨,它由 3n 块不同大小的部分组成,现在你和你的朋友们需要按照如下规则来分披萨: 
    你挑选 任意 一块披萨.
    Alice 将会挑选你所选择的披萨逆时针方向的下一块披萨.
    Bob 将会挑选你所选择的披萨顺时针方向的下一块披萨.
    重复上述过程直到没有披萨剩下.
    每一块披萨的大小按顺时针方向由循环数组 slices 表示.
    请你返回你可以获得的披萨大小总和的最大值.
#solution1389 按既定顺序创建目标数组 create-target-array-in-the-given-order Easy
    给你两个整数数组 nums 和 index.你需要按照以下规则创建目标数组: 
    目标数组 target 最初为空.
    按从左到右的顺序依次读取 nums[i] 和 index[i],在 target 数组中的下标 index[i] 处插入值 nums[i] .
    重复上一步,直到在 nums 和 index 中都没有要读取的元素.
    请你返回目标数组.
    题目保证数字插入位置总是存在.
#solution1390 四因数 four-divisors Medium
    给你一个整数数组 nums,请你返回该数组中恰有四个因数的这些整数的各因数之和.
    如果数组中不存在满足题意的整数,则返回 0 .
#solution1391 检查网格中是否存在有效路径 check-if-there-is-a-valid-path-in-a-grid Medium
    给你一个 m x n 的网格 grid.网格里的每个单元都代表一条街道.grid[i][j] 的街道可以是: 
    1 表示连接左单元格和右单元格的街道.
    2 表示连接上单元格和下单元格的街道.
    3 表示连接左单元格和下单元格的街道.
    4 表示连接右单元格和下单元格的街道.
    5 表示连接左单元格和上单元格的街道.
    6 表示连接右单元格和上单元格的街道.
#solution1392 最长快乐前缀 longest-happy-prefix Hard 
    「快乐前缀」是原字符串中既是 非空 前缀也是后缀(不包括原字符串自身)的字符串.    
    给你一个字符串 s,请你返回它的 最长快乐前缀.
    如果不存在满足题意的前缀,则返回一个空字符串.
#solution_m_01_06 字符串压缩 compress-string-lcci Easy
    字符串压缩.利用字符重复出现的次数,编写一种方法,实现基本的字符串压缩功能.比如,字符串aabcccccaaa会变为a2b1c5a3.
    若"压缩"后的字符串没有变短,则返回原先的字符串.你可以假设字符串中只包含大小写英文字母(a至z).
#solution_m_16_25 LRU缓存 lru-cache-lcci Medium
    设计和构建一个"最近最少使用"缓存,该缓存会删除最近最少使用的项目.缓存应该从键映射到值(允许你插入和检索特定键对应的值),
    并在初始化时指定最大容量.当缓存被填满时,它应该删除最近最少使用的项目.
    它应该支持以下操作: 获取数据 get 和 写入数据 put .
    获取数据 get(key) - 如果密钥 (key) 存在于缓存中,则获取密钥的值(总是正数),否则返回 -1.
    写入数据 put(key, value) - 如果密钥不存在,则写入其数据值.当缓存容量达到上限时,它应该在写入新数据之前删除最近最少使用的数据值,从而为新的数据值留出空间.
#solution_m_16_26 计算器 calculator-lcci Medium [= solution0227]
    给定一个包含正整数、加(+)、减(-)、乘(*)、除(/)的算数表达式(括号除外),计算其结果.
    表达式仅包含非负整数,+, - ,*,/ 四种运算符和空格  . 整数除法仅保留整数部分.
#solution_m_40_00 最小的k个数 zui-xiao-de-kge-shu-lcof Easy
    输入整数数组 arr ,找出其中最小的 k 个数.例如,输入4、5、1、6、2、7、3、8这8个数字,则最小的4个数字是1、2、3、4.
