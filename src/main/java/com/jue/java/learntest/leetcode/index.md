#solution0001 两数之和 two-sum Easy 
    给定一个整数数组 nums 和一个目标值 target,请你在该数组中找出和为目标值的那两个整数,并返回他们的数组下标.
    你可以假设每种输入只会对应一个答案.但是,你不能重复利用这个数组中同样的元素.
#solution0002 两数相加 add-two-numbers Medium
    给出两个非空的链表用来表示两个非负的整数.其中,它们各自的位数是按照逆序的方式存储的,并且它们的每个节点只能存储一位数字.
    如果,我们将这两个数相加起来,则会返回一个新的链表来表示它们的和.
    您可以假设除了数字0之外,这两个数都不会以0开头.
#solution0003 无重复字符的最长子串 longest-substring-without-repeating-characters Medium
    给定一个字符串,请你找出其中不含有重复字符的最长子串的长度.
#solution0004 寻找两个有序数组的中位数 median-of-two-sorted-arrays Hard
    给定两个大小为 m 和 n 的有序数组 nums1 和 nums2.
    请你找出这两个有序数组的中位数,并且要求算法的时间复杂度为 O(log(m + n)).
    你可以假设 nums1 和 nums2 不会同时为空.
#solution0005 最长回文子串 longest-palindromic-substring Medium
    给定一个字符串 s,找到 s 中最长的回文子串.你可以假设 s 的最大长度为 1000.
#solution0006 Z 字形变换 zigzag-conversion Medium
    将一个给定字符串根据给定的行数, 以从上往下、从左到右进行 Z 字形排列. 
    比如输入字符串为 "LEETCODEISHIRING" 行数为 3 时, 排列如下: 
#solution0007 整数反转 reverse-integer Easy
    给出一个 32 位的有符号整数,你需要将这个整数中每位上的数字进行反转.
#solution0008 字符串转换整数 (atoi) string-to-integer-atoi Medium
    请你来实现一个 atoi 函数, 使其能将字符串转换成整数.
    首先, 该函数会根据需要丢弃无用的开头空格字符, 直到寻找到第一个非空格的字符为止.接下来的转化规则如下: 
    如果第一个非空字符为正或者负号时, 则将该符号与之后面尽可能多的连续数字字符组合起来, 形成一个有符号整数.
    假如第一个非空字符是数字, 则直接将其与之后连续的数字字符组合起来, 形成一个整数.
    该字符串在有效的整数部分之后也可能会存在多余的字符, 那么这些字符可以被忽略, 它们对函数不应该造成影响.
    注意: 假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时, 则你的函数不需要进行转换, 即无法进行有效转换.
    在任何情况下, 若函数不能进行有效的转换时, 请返回 0,
#solution0009 回文数 palindrome-number Easy
    判断一个整数是否是回文数.回文数是指正序(从左向右)和倒序(从右向左)读都是一样的整数.
#solution0014 最长公共前缀 longest-common-prefix Easy
    编写一个函数来查找字符串数组中的最长公共前缀. 
    如果不存在公共前缀, 返回空字符串 "". 
#solution0015 三数之和 3sum Medium
    给定一个包含 n 个整数的数组 nums,判断 nums 中是否存在三个元素 a,b,c,使得 a + b + c = 0?找出所有满足条件且不重复的三元组.
    注意: 答案中不可以包含重复的三元组.
#solution0017 电话号码的字母组合 letter-combinations-of-a-phone-number Medium
    给定一个仅包含数字 2-9 的字符串,返回所有它能表示的字母组合.
    给出数字到字母的映射如下(与电话按键相同).注意 1 不对应任何字母.
#solution0022 括号生成 generate-parentheses Medium
    数字 n 代表生成括号的对数, 请你设计一个函数, 用于能够生成所有可能的并且 有效的 括号组合. 
#solution0042 接雨水 trapping-rain-water Hard
    给定 n 个非负整数表示每个宽度为 1 的柱子的高度图, 计算按此排列的柱子, 下雨之后能接多少雨水.
#solution0046 全排列 permutations Medium
    给定一个没有重复数字的序列,返回其所有可能的全排列.
#solution0049 字母异位词分组 group-anagrams Medium
    给定一个字符串数组,将字母异位词组合在一起.字母异位词指字母相同,但排列不同的字符串.
#solution0055 跳跃游戏 jump-game Medium
    给定一个非负整数数组,你最初位于数组的第一个位置.
    数组中的每个元素代表你在该位置可以跳跃的最大长度.
    判断你是否能够到达最后一个位置.
#solution0070 爬楼梯 climbing-stairs Easy
    假设你正在爬楼梯.需要 n 阶你才能到达楼顶.
    每次你可以爬 1 或 2 个台阶.你有多少种不同的方法可以爬到楼顶呢?
    注意:给定 n 是一个正整数.
#solution0072 编辑距离 edit-distance Hard
    给你两个单词 word1 和 word2, 请你计算出将 word1 转换成 word2 所使用的最少操作数. 
    你可以对一个单词进行如下三种操作: 
    插入一个字符
    删除一个字符
    替换一个字符
#solution0083 删除排序链表中的重复元素 remove-duplicates-from-sorted-list Easy
    给定一个排序链表,删除所有重复的元素,使得每个元素只出现一次.
#solution0121 买卖股票的最佳时机 best-time-to-buy-and-sell-stock Easy
    给定一个数组, 它的第 i 个元素是一支给定股票第 i 天的价格. 
    如果你最多只允许完成一笔交易(即买入和卖出一支股票一次), 设计一个算法来计算你所能获取的最大利润. 
    注意: 你不能在买入股票前卖出股票. 
#solution0151 翻转字符串里的单词 reverse-words-in-a-string Medium
    给定一个字符串, 逐个翻转字符串中的每个单词. 
#solution0168 Excel表列名称 excel-sheet-column-title Easy
    给定一个正整数,返回它在 Excel 表中相对应的列名称.
#solution0169 多数元素 majority-element Easy
    给定一个大小为 n 的数组,找到其中的多数元素.多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素.
    你可以假设数组是非空的,并且给定的数组总是存在多数元素.
#solution0175 组合两个表 combine-two-tables Easy @SQL
    编写一个 SQL 查询,满足条件: 无论 person 是否有地址信息,都需要基于上述两表提供 person 的以下信息: 
#solution0176 第二高的薪水 second-highest-salary Easy @SQL
    例如上述 Employee 表,SQL查询应该返回 200 作为第二高的薪水.如果不存在第二高的薪水,那么查询应返回 null.
#solution0177 第N高的薪水 nth-highest-salary Medium @SQL
    例如上述 Employee 表,n = 2 时,应返回第二高的薪水 200.如果不存在第 n 高的薪水,那么查询应返回 null.
#solution0178 分数排名 rank-scores Medium @SQL
    编写一个 SQL 查询来实现分数排名.如果两个分数相同,则两个分数排名(Rank)相同.请注意,平分后的下一个名次应该是下一个连续的整数值.换句话说,名次之间不应该有"间隔".
#solution0180 连续出现的数字 consecutive-numbers Medium @SQL
    编写一个 SQL 查询,查找所有至少连续出现三次的数字.
#solution0181 超过经理收入的员工 employees-earning-more-than-their-managers Easy @SQL
    Employee 表包含所有员工,他们的经理也属于员工.每个员工都有一个 Id,此外还有一列对应员工的经理的 Id.
#solution0182 查找重复的电子邮箱 duplicate-emails Easy @SQL
    编写一个 SQL 查询,查找 Person 表中所有重复的电子邮箱.
#solution0183 从不订购的客户 customers-who-never-order Easy @SQL
    某网站包含两个表,Customers 表和 Orders 表.编写一个 SQL 查询,找出所有从不订购任何东西的客户.
#solution0184 部门工资最高的员工 department-highest-salary Medium @SQL
    编写一个 SQL 查询,找出每个部门工资最高的员工.例如,根据上述给定的表格,Max 在 IT 部门有最高工资,Henry 在 Sales 部门有最高工资
#solution0185 部门工资前三高的所有员工 department-top-three-salaries Hard @SQL
    编写一个 SQL 查询,找出每个部门获得前三高工资的所有员工.例如,根据上述给定的表,查询结果应返回: 
#solution0196 删除重复的电子邮箱 delete-duplicate-emails Easy @SQL
    编写一个 SQL 查询,来删除 Person 表中所有重复的电子邮箱,重复的邮箱里只保留 Id 最小 的那个.
#solution0197 上升的温度 rising-temperature Easy @SQL
    给定一个 Weather 表,编写一个 SQL 查询,来查找与之前(昨天的)日期相比温度更高的所有日期的 Id.
#solution0198 打家劫舍 house-robber Easy
    你是一个专业的小偷,计划偷窃沿街的房屋.每间房内都藏有一定的现金,影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统,如果两间相邻的房屋在同一晚上被小偷闯入,系统会自动报警.
    给定一个代表每个房屋存放金额的非负整数数组,计算你在不触动警报装置的情况下,能够偷窃到的最高金额.
#solution0200 岛屿数量 number-of-islands Medium
    给定一个由 '1'(陆地)和 '0'(水)组成的的二维网格,计算岛屿的数量.一个岛被水包围,并且它是通过水平方向或垂直方向上相邻的陆地连接而成的.你可以假设网格的四个边均被水包围.
#solution0213 打家劫舍 II house-robber-ii Medium
    你是一个专业的小偷,计划偷窃沿街的房屋,每间房内都藏有一定的现金.这个地方所有的房屋都围成一圈,这意味着第一个房屋和最后一个房屋是紧挨着的.
    同时,相邻的房屋装有相互连通的防盗系统,如果两间相邻的房屋在同一晚上被小偷闯入,系统会自动报警.
    给定一个代表每个房屋存放金额的非负整数数组,计算你在不触动警报装置的情况下,能够偷窃到的最高金额.
#solution0214 最短回文串 shortest-palindrome Hard
    给定一个字符串 s, 你可以通过在字符串前面添加字符将其转换为回文串. 找到并返回可以用这种方式转换的最短回文串. 
#solution0216 组合总和 III combination-sum-iii Medium
    找出所有相加之和为 n 的 k 个数的组合. 组合中只允许含有 1 - 9 的正整数, 并且每种组合中不存在重复的数字. 
#solution0223 矩形面积 rectangle-area Medium
    在二维平面上计算出两个由直线构成的矩形重叠后形成的总面积.
    每个矩形由其左下顶点和右上顶点坐标表示,如图所示.
#solution0227 基本计算器 II basic-calculator-ii Medium
    实现一个基本的计算器来计算一个简单的字符串表达式的值.
    字符串表达式仅包含非负整数,+, -,*,/ 四种运算符和空格, 整数除法仅保留整数部分.
#solution0262 行程和用户 trips-and-users Hard @SQL
    写一段 SQL 语句查出 2013年10月1日 至 2013年10月3日 期间非禁止用户的取消率.基于上表,你的 SQL 语句应返回如下结果,取消率(Cancellation Rate)保留两位小数.
    取消率的计算方式如下: (被司机或乘客取消的非禁止用户生成的订单数量) / (非禁止用户生成的订单总数)
#solution0279 完全平方数 perfect-squares Medium
    给定正整数 n,找到若干个完全平方数(比如 1, 4, 9, 16,,..)使得它们的和等于 n.你需要让组成和的完全平方数的个数最少.
#solution0289 生命游戏 game-of-life Medium
    根据 百度百科 , 生命游戏, 简称为生命, 是英国数学家约翰·何顿·康威在 1970 年发明的细胞自动机.
    给定一个包含 m × n 个格子的面板, 每一个格子都可以看成是一个细胞.每个细胞都具有一个初始状态: 1 即为活细胞(live), 或 0 即为死细胞(dead).每个细胞与其八个相邻位置(水平, 垂直, 对角线)的细胞都遵循以下四条生存定律: 
    如果活细胞周围八个位置的活细胞数少于两个, 则该位置活细胞死亡；
    如果活细胞周围八个位置有两个或三个活细胞, 则该位置活细胞仍然存活；
    如果活细胞周围八个位置有超过三个活细胞, 则该位置活细胞死亡；
    如果死细胞周围正好有三个活细胞, 则该位置死细胞复活；
    根据当前状态, 写一个函数来计算面板上所有细胞的下一个(一次更新后的)状态.下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的, 其中细胞的出生和死亡是同时发生的.
#solution0300 最长上升子序列 longest-increasing-subsequence Medium
    给定一个无序的整数数组,找到其中最长上升子序列的长度.
#solution0319 灯泡开关 bulb-switcher Medium
    初始时有 n 个灯泡关闭.  第 1 轮, 你打开所有的灯泡.  第 2 轮, 每两个灯泡你关闭一次.  
    第 3 轮, 每三个灯泡切换一次开关(如果关闭则开启, 如果开启则关闭). 
    第 i 轮, 每 i 个灯泡切换一次开关.  对于第 n 轮, 你只切换最后一个灯泡的开关.  找出 n 轮后有多少个亮着的灯泡. 
#solution0329 矩阵中的最长递增路径 longest-increasing-path-in-a-matrix Hard
    给定一个整数矩阵,找出最长递增路径的长度.
    对于每个单元格,你可以往上,下,左,右四个方向移动. 你不能在对角线方向上移动或移动到边界外(即不允许环绕).
#solution0355 设计推特 design-twitter Medium
    设计一个简化版的推特(Twitter), 可以让用户实现发送推文, 关注/取消关注其他用户, 能够看见关注人（包括自己）的最近十条推文. 你的设计需要支持以下的几个功能: 
    postTweet(userId, tweetId): 创建一条新的推文
    getNewsFeed(userId): 检索最近的十条推文. 每个推文都必须是由此用户关注的人或者是用户自己发出的. 推文必须按照时间顺序由最近的开始排序. 
    follow(followerId, followeeId): 关注一个用户
    unfollow(followerId, followeeId): 取消关注一个用户
#solution0365 水壶问题 water-and-jug-problem Medium
    有两个容量分别为 x升 和 y升 的水壶以及无限多的水.请判断能否通过使用这两个水壶,从而可以得到恰好 z升 的水?
    如果可以,最后请用以上水壶中的一或两个来盛放取得的 z升 水.
    你允许: 
    装满任意一个水壶
    清空任意一个水壶
    从一个水壶向另外一个水壶倒水,直到装满或者倒空
#solution0368 最大整除子集 largest-divisible-subset Medium
    给出一个由无重复的正整数组成的集合,找出其中最大的整除子集,子集中任意一对 (Si,Sj) 都要满足: Si % Sj = 0 或 Sj % Si = 0.
    如果有多个目标子集,返回其中任何一个均可.
#solution0407 接雨水 II trapping-rain-water-ii Hard
    给定一个 m x n 的矩阵,其中的值均为正整数,代表二维高度图每个单元的高度,请计算图中形状最多能接多少体积的雨水.
#solution0409 最长回文串 longest-palindrome Easy
    给定一个包含大写字母和小写字母的字符串,找到通过这些字母构造成的最长的回文串.
    在构造过程中,请注意区分大小写.比如 "Aa" 不能当做一个回文字符串.
    注意:假设字符串的长度不会超过 1010.
#solution0419 甲板上的战舰 battleships-in-a-board Medium
    给定一个二维的甲板, 请计算其中有多少艘战舰. 战舰用 'X'表示,空位用 '.'表示. 你需要遵守以下规则:
    给你一个有效的甲板,仅由战舰或者空位组成.
    战舰只能水平或者垂直放置.换句话说,战舰只能由 1xN (1 行, N 列)组成,或者 Nx1 (N 行, 1 列)组成,其中N可以是任意大小.
    两艘战舰之间至少有一个水平或垂直的空位分隔 - 即没有相邻的战舰.
#solution0460 LFU缓存 lfu-cache Hard
    设计并实现最不经常使用(LFU)缓存的数据结构.它应该支持以下操作: get 和 put.
    get(key) - 如果键存在于缓存中, 则获取键的值(总是正数), 否则返回 -1.
    put(key, value) - 如果键不存在, 请设置或插入值.当缓存达到其容量时, 它应该在插入新项目之前, 使最不经常使用的项目无效.在此问题中, 当存在平局(即两个或更多个键具有相同使用频率)时, 最近最少使用的键将被去除.
#solution0595 大的国家 big-countries Easy @SQL
    如果一个国家的面积超过300万平方公里,或者人口超过2500万,那么这个国家就是大国家.
    编写一个SQL查询,输出表中所有大国家的名称、人口和面积.
#solution0596 超过5名学生的课 classes-more-than-5-students Easy @SQL
    请列出所有超过或等于5名学生的课.
#solution0601 体育馆的人流量 human-traffic-of-stadium Hard @SQL
    X 市建了一个新的体育馆,每日人流量信息被记录在这三列信息中: 序号 (id)、日期 (visit_date)、 人流量 (people).
    请编写一个查询语句,找出人流量的高峰期.高峰期时,至少连续三行记录中的人流量不少于100.
#solution0620 有趣的电影 not-boring-movies Easy @SQL
    某城市开了一家新的电影院,吸引了很多人过来看电影.该电影院特别注意用户体验,专门有个 LED显示板做电影推荐,上面公布着影评和相关电影描述.
    作为该电影院的信息部主管,您需要编写一个 SQL查询,找出所有影片描述为非 boring (不无聊) 的并且 id 为奇数 的影片,结果请按等级 rating 排列.
#solution0626 换座位 exchange-seats Medium @SQL
    小美是一所中学的信息科技老师,她有一张 seat 座位表,平时用来储存学生名字和与他们相对应的座位 id.
    其中纵列的 id 是连续递增的
    小美想改变相邻俩学生的座位.
    你能不能帮她写一个 SQL query 来输出小美想要的结果呢?
#solution0627 交换工资 swap-salary Easy @SQL
    给定一个 salary 表,如下所示,有 m = 男性 和 f = 女性 的值.交换所有的 f 和 m 值(例如,将所有 f 值更改为 m,反之亦然).要求只使用一个更新(Update)语句,并且没有中间的临时表.
    注意,您必只能写一个 Update 语句,请不要编写任何 Select 语句.
#solution0673 最长递增子序列的个数 number-of-longest-increasing-subsequence Medium
    给定一个未排序的整数数组,找到最长递增子序列的个数.
#solution0677 键值映射 map-sum-pairs Medium
    实现一个 MapSum 类里的两个方法,insert 和 sum.
    对于方法 insert,你将得到一对(字符串,整数)的键值对.字符串表示键,整数表示值.如果键已经存在,那么原来的键值对将被替代成新的键值对.
    对于方法 sum,你将得到一个表示前缀的字符串,你需要返回所有以该前缀开头的键的值的总和.
#solution0695 岛屿的最大面积 max-area-of-island Medium
    给定一个包含了一些 0 和 1的非空二维数组 grid , 一个 岛屿 是由四个方向 (水平或垂直) 的 1 (代表土地) 构成的组合.你可以假设二维矩阵的四个边缘都被水包围着.
    找到给定的二维数组中最大的岛屿面积.(如果没有岛屿,则返回面积为0.)
#solution0764 最大加号标志 largest-plus-sign Medium
    在一个大小在 (0, 0) 到 (N-1, N-1) 的2D网格 grid 中, 除了在 mines 中给出的单元为 0, 其他每个单元都是 1. 
    网格中包含 1 的最大的轴对齐加号标志是多少阶? 返回加号标志的阶数. 如果未找到加号标志, 则返回 0. 
    一个 k" 阶由 1 组成的"轴对称"加号标志具有中心网格  grid[x][y] = 1 , 以及4个从中心向上、向下、向左、向右延伸, 长度为 k-1, 由 1 组成的臂. 
    下面给出 k" 阶"轴对称"加号标志的示例. 注意, 只有加号标志的所有网格要求为 1, 别的网格可能为 0 也可能为 1. 
#solution0820 单词的压缩编码 short-encoding-of-words Medium
    给定一个单词列表, 我们将这个列表编码成一个索引字符串 S 与一个索引列表 A. 
    例如, 如果这个列表是 ["time", "me", "bell"], 我们就可以将其表示为 S = "time#bell#" 和 indexes = [0, 2, 5]. 
    对于每一个索引, 我们可以通过从字符串 S 中索引的位置开始读取字符串, 直到 "#" 结束, 来恢复我们之前的单词列表. 
    那么成功对给定单词列表进行编码的最小字符串长度是多少呢? 
#solution0828 统计子串中的唯一字符 count-unique-characters-of-all-substrings-of-a-given-string Hard
    我们定义了一个函数 countUniqueChars(s) 来统计字符串 s 中的唯一字符,并返回唯一字符的个数.
    例如: s = "LEETCODE",则其中 "L", "T","C","O","D" 都是唯一字符,因为它们只出现一次,所以 countUniqueChars(s) = 5,
    本题将会给你一个字符串 s,我们需要返回 countUniqueChars(t) 的总和,其中 t 是 s 的子字符串.注意,某些子字符串可能是重复的,
    但你统计时也必须算上这些重复的子字符串(也就是说,你必须统计 s 的所有子字符串中的唯一字符).
    由于答案可能非常大,请将结果 mod 10 ^ 9 + 7 后再返回.
#solution0829 连续整数求和 consecutive-numbers-sum Hard
    给定一个正整数 N,试求有多少组连续正整数满足所有数字之和为 N?
#solution0830 较大分组的位置 positions-of-large-groups Easy
    在一个由小写字母构成的字符串 S 中,包含由一些连续的相同字符所构成的分组.
    例如,在字符串 S = "abbxxxxzyy" 中,就含有 "a", "bb", "xxxx", "z" 和 "yy" 这样的一些分组.
    我们称所有包含大于或等于三个连续字符的分组为较大分组.找到每一个较大分组的起始和终止位置.
    最终结果按照字典顺序输出.
#solution0831 隐藏个人信息 masking-personal-information Medium
    给你一条个人信息 string S,它可能是一个邮箱地址,也可能是一个电话号码.
    我们将隐藏它的隐私信息,通过如下规则:
    <u>1. 电子邮箱</u>
    定义名称 <name> 是长度大于等于 2 (length ≥ 2),并且只包含小写字母 a-z 和大写字母 A-Z 的字符串.
    电子邮箱地址由名称 <name> 开头,紧接着是符号 <font face="Menlo, Monaco, Consolas, Courier New, monospace">'@'</font>,后面接着一个名称 <name>,再接着一个点号 '.',然后是一个名称 <name>.
    电子邮箱地址确定为有效的,并且格式是 "name1@name2.name3".
    为了隐藏电子邮箱,所有的名称 <name> 必须被转换成小写的,并且第一个名称 <name> 的第一个字母和最后一个字母的中间的所有字母由 5 个 '*' 代替.
    <u>2. 电话号码</u>
    电话号码是一串包括数字 0-9,以及 {'+', '-', '(', ')', ' '} 这几个字符的字符串.你可以假设电话号码包含 10 到 13 个数字.
    电话号码的最后 10 个数字组成本地号码,在这之前的数字组成国际号码.注意,国际号码是可选的.我们只暴露最后 4 个数字并隐藏所有其他数字.
    本地号码是有格式的,并且如 "***-***-1111" 这样显示,这里的 1 表示暴露的数字.
    为了隐藏有国际号码的电话号码,像 "+111 111 111 1111",我们以 "+***-***-***-1111" 的格式来显示.在本地号码前面的 '+' 号和第一个 '-' 号仅当电话号码中包含国际号码时存在.
    例如,一个 12 位的电话号码应当以 "+**-" 开头进行显示.
    注意: 像 "(",")"," " 这样的不相干的字符以及不符合上述格式的额外的减号或者加号都应当被删除.
    最后,将提供的信息正确隐藏后返回.
#solution0836 矩形重叠 rectangle-overlap Easy
    矩形以列表 [x1, y1, x2, y2] 的形式表示,其中 (x1, y1) 为左下角的坐标,(x2, y2) 是右上角的坐标. 
    如果相交的面积为正,则称两矩形重叠.需要明确的是,只在角或边接触的两个矩形不构成重叠.
    给出两个矩形,判断它们是否重叠并返回结果.
#solution0860 柠檬水找零 lemonade-change Easy
    在柠檬水摊上,每一杯柠檬水的售价为 5 美元.
    顾客排队购买你的产品,(按账单 bills 支付的顺序)一次购买一杯.
    每位顾客只买一杯柠檬水,然后向你付 5 美元,10 美元或 20 美元.你必须给每个顾客正确找零,也就是说净交易是每位顾客向你支付 5 美元.
    注意,一开始你手头没有任何零钱.
    如果你能给每位顾客正确找零,返回 true ,否则返回 false.
#solution0865 具有所有最深结点的最小子树 smallest-subtree-with-all-the-deepest-nodes Medium
    给定一个根为 root 的二叉树,每个结点的深度是它到根的最短距离.
    如果一个结点在整个树的任意结点之间具有最大的深度,则该结点是最深的.
    一个结点的子树是该结点加上它的所有后代的集合.
    返回能满足"以该结点为根的子树中包含所有最深的结点"这一条件的具有最大深度的结点.
#solution0876 链表的中间结点 middle-of-the-linked-list Easy
    给定一个带有头结点 head 的非空单链表,返回链表的中间结点.
    如果有两个中间结点,则返回第二个中间结点.
#solution0877 石子游戏 stone-game Medium
    亚历克斯和李用几堆石子在做游戏. 偶数堆石子排成一行, 每堆都有正整数颗石子 piles[i]. 
    游戏以谁手中的石子最多来决出胜负. 石子的总数是奇数, 所以没有平局. 
    亚历克斯和李轮流进行, 亚历克斯先开始.  每回合, 玩家从行的开始或结束处取走整堆石头.  这种情况一直持续到没有更多的石子堆为止, 此时手中石子最多的玩家获胜. 
    假设亚历克斯和李都发挥出最佳水平, 当亚历克斯赢得比赛时返回 true , 当李赢得比赛时返回 false. 
#solution0887 鸡蛋掉落 super-egg-drop Hard
    你将获得 K 个鸡蛋, 并可以使用一栋从 1 到 N  共有 N 层楼的建筑. 
    每个蛋的功能都是一样的, 如果一个蛋碎了, 你就不能再把它掉下去. 
    你知道存在楼层 F, 满足 0 <= F <= N 任何从高于 F 的楼层落下的鸡蛋都会碎, 从 F 楼层或比它低的楼层落下的鸡蛋都不会破. 
    每次移动, 你可以取一个鸡蛋(如果你有完整的鸡蛋)并把它从任一楼层 X 扔下(满足 1 <= X <= N). 
    你的目标是确切地知道 F 的值是多少. 
    无论 F 的初始值如何, 你确定 F 的值的最小移动次数是多少? 
#solution0892 三维形体的表面积 surface-area-of-3d-shapes Easy
    在 N * N 的网格上, 我们放置一些 1 * 1 * 1  的立方体. 
    每个值 v = grid[i][j] 表示 v 个正方体叠放在对应单元格 (i, j) 上. 
    请你返回最终形体的表面积. 
#solution0912 排序数组 sort-an-array Medium
    给你一个整数数组 nums, 请你将该数组升序排列. 
#solution0914 卡牌分组 x-of-a-kind-in-a-deck-of-cards Easy
    给定一副牌, 每张牌上都写着一个整数. 
    此时, 你需要选定一个数字 X, 使我们可以将整副牌按下述规则分成 1 组或更多组: 
    每组都有 X 张牌. 
    组内所有的牌上都写着相同的整数. 
    仅当你可选的 X >= 2 时返回 true. 
#solution0931 下降路径最小和 minimum-falling-path-sum Medium
    给定一个方形整数数组 A, 我们想要得到通过 A 的下降路径的最小和. 
    下降路径可以从第一行中的任何元素开始, 并从每一行中选择一个元素. 在下一行选择的元素和当前行所选元素最多相隔一列. 
#solution0945 使数组唯一的最小增量 minimum-increment-to-make-array-unique Medium
    给定整数数组 A,每次 move 操作将会选择任意 A[i],并将其递增 1.
    返回使 A 中的每个值都是唯一的最少操作次数.
#solution0991 坏了的计算器 broken-calculator Medium
    在显示着数字的坏计算器上,我们可以执行以下两种操作: 
    双倍(Double): 将显示屏上的数字乘 2；
    递减(Decrement): 将显示屏上的数字减 1,
    最初,计算器显示数字 X.
    返回显示数字 Y 所需的最小操作数.
#solution0999 车的可用捕获量 available-captures-for-rook Easy
    在一个 8 x 8 的棋盘上, 有一个白色车(rook). 也可能有空方块, 白色的象(bishop)和黑色的卒(pawn). 它们分别以字符 "R", ".", "B" 和 "p" 给出. 大写字符表示白棋, 小写字符表示黑棋. 
    车按国际象棋中的规则移动: 它选择四个基本方向中的一个(北, 东, 西和南), 然后朝那个方向移动, 直到它选择停止、到达棋盘的边缘或移动到同一方格来捕获该方格上颜色相反的卒. 另外, 车不能与其他友方(白色)象进入同一个方格. 
    返回车能够在一次移动中捕获到的卒的数量. 
#solution1012 至少有 1 位重复的数字 numbers-with-repeated-digits Hard
    给定正整数 N, 返回小于等于 N 且具有至少 1 位重复数字的正整数. 
#solution1052 爱生气的书店老板 grumpy-bookstore-owner Medium
    今天,书店老板有一家店打算试营业 customers.length 分钟.每分钟都有一些顾客(customers[i])会进入书店,所有这些顾客都会在那一分钟结束后离开.
    在某些时候,书店老板会生气. 如果书店老板在第 i 分钟生气,那么 grumpy[i] = 1,否则 grumpy[i] = 0. 当书店老板生气时,那一分钟的顾客就会不满意,不生气则他们是满意的.
    书店老板知道一个秘密技巧,能抑制自己的情绪,可以让自己连续 X 分钟不生气,但却只能使用一次.
    请你返回这一天营业下来,最多有多少客户能够感到满意的数量.
#solution1071 字符串的最大公因子 greatest-common-divisor-of-strings Easy
    对于字符串 S 和 T,只有在 S = T +,.. + T(T 与自身连接 1 次或多次)时,我们才认定 "T 能除尽 S".
    返回最长字符串 X,要求满足 X 能除尽 str1 且 X 能除尽 str2.
#solution1111 有效括号的嵌套深度 maximum-nesting-depth-of-two-valid-parentheses-strings Medium
    给你一个有效括号字符串 seq, 将其分成两个不相交的子序列 A 和 B, 且 A 和 B 满足有效括号字符串的定义(注意: A.length + B.length = seq.length). 
    现在, 你需要从中选出 任意 一组有效括号字符串 A 和 B, 使 max(depth(A), depth(B)) 的可能取值最小. 
    返回长度为 seq.length 答案数组 answer , 选择 A 还是 B 的编码规则是: 如果 seq[i] 是 A 的一部分, 那么 answer[i] = 0. 否则, answer[i] = 1. 即便有多个满足要求的答案存在, 你也只需返回 一个. 
#solution1140 石子游戏II stone-game-ii Medium
    亚历克斯和李继续他们的石子游戏. 许多堆石子 排成一行, 每堆都有正整数颗石子 piles[i]. 游戏以谁手中的石子最多来决出胜负. 
    亚历克斯和李轮流进行, 亚历克斯先开始. 最初, M = 1. 
    在每个玩家的回合中, 该玩家可以拿走剩下的 前 X 堆的所有石子, 其中 1 <= X <= 2M. 然后, 令 M = max(M, X). 
    游戏一直持续到所有石子都被拿走. 
    假设亚历克斯和李都发挥出最佳水平, 返回亚历克斯可以得到的最大数量的石头. 
#solution1155 掷骰子的N种方法 number-of-dice-rolls-with-target-sum Medium
    这里有 d 个一样的骰子,每个骰子上都有 f 个面,分别标号为 1, 2,,.., f.
    我们约定: 掷骰子的得到总点数为各骰子面朝上的数字的总和.
    如果需要掷出的总点数为 target,请你计算出有多少种不同的组合情况(所有的组合情况总共有 f^d 种),模 10^9 + 7 后返回.
#solution1160 拼写单词 find-words-that-can-be-formed-by-characters Easy
    给你一份『词汇表』(字符串数组) words 和一张『字母表』(字符串) chars.
    假如你可以用 chars 中的『字母』(字符)拼写出 words 中的某个『单词』(字符串),那么我们就认为你掌握了这个单词.
    注意: 每次拼写时,chars 中的每个字母都只能用一次.
    返回词汇表 words 中你掌握的所有单词的 长度之和.
#solution1162 地图分析 as-far-from-land-as-possible Medium
    你现在手里有一份大小为 N x N 的『地图』(网格) grid, 上面的每个『区域』(单元格)都用 0 和 1 标记好了. 
    其中 0 代表海洋, 1 代表陆地, 你知道距离陆地区域最远的海洋区域是是哪一个吗? 请返回该海洋区域到离它最近的陆地区域的距离. 
    我们这里说的距离是『曼哈顿距离』( Manhattan Distance): (x0, y0) 和 (x1, y1) 这两个区域之间的距离是 |x0 - x1| + |y0 - y1|. 
    如果我们的地图上只有陆地或者海洋, 请返回 -1. 
#solution1179 重新格式化部门表 reformat-department-table Easy
    编写一个 SQL 查询来重新格式化表,使得新的表中有一个部门 id 列和一些对应 每个月 的收入(revenue)列.
#solution1269 停在原地的方案数 number-of-ways-to-stay-in-the-same-place-after-some-steps Hard
    有一个长度为 arrLen 的数组,开始有一个指针在索引 0 处.
    每一步操作中,你可以将指针向左或向右移动 1 步,或者停在原地(指针不能被移动到数组范围外).
    给你两个整数 steps 和 arrLen,请你计算并返回: 在恰好执行 steps 次操作以后,指针仍然指向索引 0 处的方案数.
    由于答案可能会很大,请返回方案数 模 10^9 + 7 后的结果.
#solution1306 跳跃游戏 III jump-game-iii Medium
    这里有一个非负整数数组 arr,你最开始位于该数组的起始下标 start 处.当你位于下标 i 处时,你可以跳到 i + arr[i] 或者 i - arr[i].
    请你判断自己是否能够跳到对应元素值为 0 的 任意 下标处.
    注意,不管是什么情况下,你都无法跳到数组之外.
#solution1380 矩阵中的幸运数 lucky-numbers-in-a-matrix Easy
    给你一个 m * n 的矩阵,矩阵中的数字 各不相同,请你按 任意 顺序返回矩阵中的所有幸运数.
    幸运数是指矩阵中满足同时下列两个条件的元素:
    在同一行的所有元素中最小
    在同一列的所有元素中最大
#solution1381 设计一个支持增量操作的栈 design-a-stack-with-increment-operation Medium
    请你设计一个支持下述操作的栈.
    实现自定义栈类 CustomStack :
    CustomStack(int maxSize):用 maxSize 初始化对象,maxSize 是栈中最多能容纳的元素数量,栈在增长到 maxSize 之后则不支持 push 操作.
    void push(int x):如果栈还未增长到 maxSize,就将 x 添加到栈顶.
    int pop():返回栈顶的值,或栈为空时返回 -1,
    void inc(int k, int val):栈底的 k 个元素的值都增加 val,如果栈中元素总数小于 k,则栈中的所有元素都增加 val,
#solution1382 将二叉搜索树变平衡 balance-a-binary-search-tree Medium
    给你一棵二叉搜索树,请你返回一棵 平衡后 的二叉搜索树,新生成的树应该与原来的树有着相同的节点值.
    如果一棵二叉搜索树中,每个节点的两棵子树高度差不超过 1,我们就称这棵二叉搜索树是 平衡的,
    如果有多种构造方法,请你返回任意一种.
#solution1383 最大的团队表现值 maximum-performance-of-a-team Hard
    公司有编号为 1 到 n 的 n 个工程师,给你两个数组 speed 和 efficiency,其中 speed[i] 和 efficiency[i] 分别代表第 i 位工程师的速度和效率.
    请你返回由最多 k 个工程师组成的最大团队表现值,由于答案可能很大,请你返回结果对 10^9 + 7 取余后的结果.
    团队表现值 的定义为:一个团队中「所有工程师速度的和」乘以他们「效率值中的最小值」.
#solution1385 两个数组间的距离值 find-the-distance-value-between-two-arrays Easy
    给你两个整数数组 arr1, arr2 和一个整数 d,请你返回两个数组之间的 距离值,
    「距离值」 定义为符合此描述的元素数目: 对于元素 arr1[i],不存在任何元素 arr2[j] 满足 |arr1[i]-arr2[j]| <= d,
#solution1386 安排电影院座位 cinema-seat-allocation Medium
    如上图所示,电影院的观影厅中有 n 行座位,行编号从 1 到 n,且每一行内总共有 10 个座位,列编号从 1 到 10,
    给你数组 reservedSeats,包含所有已经被预约了的座位.比如说,researvedSeats[i]=[3,8],它表示第 3 行第 8 个座位被预约了.
    请你返回 最多能安排多少个 4 人家庭,4 人家庭要占据 同一行内连续 的 4 个座位.隔着过道的座位(比方说 [3,3] 和 [3,4])不是连续的座位,
    但是如果你可以将 4 人家庭拆成过道两边各坐 2 人,这样子是允许的.
#solution1387 将整数按权重排序 sort-integers-by-the-power-value Medium
    我们将整数 x 的 权重 定义为按照下述规则将 x 变成 1 所需要的步数: 
    如果 x 是偶数,那么 x = x / 2
    如果 x 是奇数,那么 x = 3 * x + 1
    比方说,x=3 的权重为 7,因为 3 需要 7 步变成 1 (3 --> 10 --> 5 --> 16 --> 8 --> 4 --> 2 --> 1).
    给你三个整数 lo, hi 和 k,你的任务是将区间 [lo, hi] 之间的整数按照它们的权重 升序排序,如果大于等于 2 个整数有 相同 的权重,那么按照数字自身的数值 升序排序,
    请你返回区间 [lo, hi] 之间的整数按权重排序后的第 k 个数.
    注意,题目保证对于任意整数 x (lo <= x <= hi),它变成 1 所需要的步数是一个 32 位有符号整数.
#solution1388 3n块披萨 pizza-with-3n-slices Hard
    给你一个披萨,它由 3n 块不同大小的部分组成,现在你和你的朋友们需要按照如下规则来分披萨: 
    你挑选 任意 一块披萨.
    Alice 将会挑选你所选择的披萨逆时针方向的下一块披萨.
    Bob 将会挑选你所选择的披萨顺时针方向的下一块披萨.
    重复上述过程直到没有披萨剩下.
    每一块披萨的大小按顺时针方向由循环数组 slices 表示.
    请你返回你可以获得的披萨大小总和的最大值.
#solution1389 按既定顺序创建目标数组 create-target-array-in-the-given-order Easy
    给你两个整数数组 nums 和 index.你需要按照以下规则创建目标数组: 
    目标数组 target 最初为空.
    按从左到右的顺序依次读取 nums[i] 和 index[i],在 target 数组中的下标 index[i] 处插入值 nums[i],
    重复上一步,直到在 nums 和 index 中都没有要读取的元素.
    请你返回目标数组.
    题目保证数字插入位置总是存在.
#solution1390 四因数 four-divisors Medium
    给你一个整数数组 nums,请你返回该数组中恰有四个因数的这些整数的各因数之和.
    如果数组中不存在满足题意的整数,则返回 0,
#solution1391 检查网格中是否存在有效路径 check-if-there-is-a-valid-path-in-a-grid Medium
    给你一个 m x n 的网格 grid.网格里的每个单元都代表一条街道.grid[i][j] 的街道可以是: 
    1 表示连接左单元格和右单元格的街道.
    2 表示连接上单元格和下单元格的街道.
    3 表示连接左单元格和下单元格的街道.
    4 表示连接右单元格和下单元格的街道.
    5 表示连接左单元格和上单元格的街道.
    6 表示连接右单元格和上单元格的街道.
#solution1392 最长快乐前缀 longest-happy-prefix Hard 
    「快乐前缀」是原字符串中既是 非空 前缀也是后缀(不包括原字符串自身)的字符串.    
    给你一个字符串 s,请你返回它的 最长快乐前缀.
    如果不存在满足题意的前缀,则返回一个空字符串.
#solution1394 找出数组中的幸运数 find-lucky-integer-in-an-array Easy
    在整数数组中, 如果一个整数的出现频次和它的数值大小相等, 我们就称这个整数为「幸运数」. 
    给你一个整数数组 arr, 请你从中找出并返回一个幸运数. 
    如果数组中存在多个幸运数, 只需返回 最大 的那个. 
    如果数组中不含幸运数, 则返回 -1, 
#solution1395 统计作战单位数 count-number-of-teams Medium
     n 名士兵站成一排. 每个士兵都有一个 独一无二 的评分 rating. 
    每 3 个士兵可以组成一个作战单位, 分组规则如下: 
    从队伍中选出下标分别为 i、j、k 的 3 名士兵, 他们的评分分别为 rating[i]、rating[j]、rating[k]
    作战单位需满足:  rating[i] < rating[j] < rating[k] 或者 rating[i] > rating[j] > rating[k], 其中  0 <= i < j < k < n
    请你返回按上述条件可以组建的作战单位数量. 每个士兵都可以是多个作战单位的一部分. 
#solution1396 设计地铁系统 design-underground-system Medium
    请你实现一个类 UndergroundSystem , 它支持以下 3 种方法: 
    1. checkIn(int id, string stationName, int t)
    编号为 id 的乘客在 t 时刻进入地铁站 stationName. 
    一个乘客在同一时间只能在一个地铁站进入或者离开. 
    2. checkOut(int id, string stationName, int t)
    编号为 id 的乘客在 t 时刻离开地铁站 stationName. 
    3. getAverageTime(string startStation, string endStation) 
    返回从地铁站 startStation 到地铁站 endStation 的平均花费时间. 
    平均时间计算的行程包括当前为止所有从 startStation 直接到达 endStation 的行程. 
    调用 getAverageTime 时, 询问的路线至少包含一趟行程. 
    你可以假设所有对 checkIn 和 checkOut 的调用都是符合逻辑的. 也就是说, 如果一个顾客在 t1 时刻到达某个地铁站, 那么他离开的时间 t2 一定满足 t2 > t1. 所有的事件都按时间顺序给出. 
#solution1397 找到所有好字符串 find-all-good-strings Hard
    给你两个长度为 n 的字符串 s1 和 s2 , 以及一个字符串 evil. 请你返回 好字符串 的数目. 
    好字符串 的定义为: 它的长度为 n , 字典序大于等于 s1 , 字典序小于等于 s2 , 且不包含 evil 为子字符串. 
    由于答案可能很大, 请你返回答案对 10^9 + 7 取余的结果. 
#solution1403 非递增顺序的最小子序列 minimum-subsequence-in-non-increasing-order Easy
    给你一个数组 nums, 请你从中抽取一个子序列, 满足该子序列的元素之和 严格 大于未包含在该子序列中的各元素之和. 
    如果存在多个解决方案, 只需返回 长度最小 的子序列. 如果仍然有多个解决方案, 则返回 元素之和最大 的子序列. 
    与子数组不同的地方在于, 「数组的子序列」不强调元素在原数组中的连续性, 也就是说, 它可以通过从数组中分离一些(也可能不分离)元素得到. 
    注意, 题目数据保证满足所有约束条件的解决方案是 唯一 的. 同时, 返回的答案应当按 非递增顺序 排列. 
#solution1404 将二进制表示减到1的步骤数 number-of-steps-to-reduce-a-number-in-binary-representation-to-one Medium
    给你一个以二进制形式表示的数字 s, 请你返回按下述规则将其减少到 1 所需要的步骤数: 
    如果当前数字为偶数, 则将其除以 2, 
    如果当前数字为奇数, 则将其加上 1, 
    题目保证你总是可以按上述规则将测试用例变为 1, 
#solution1405 最长快乐字符串 longest-happy-string Medium
    如果字符串中不含有任何 'aaa', 'bbb' 或 'ccc' 这样的字符串作为子串, 那么该字符串就是一个「快乐字符串」. 
    给你三个整数 a, b, c, 请你返回 任意一个 满足下列全部条件的字符串 s: 
    s 是一个尽可能长的快乐字符串. 
    s 中 最多 有a 个字母 'a'、b 个字母 'b'、c 个字母 'c', 
    s 中只含有 'a'、'b' 、'c' 三种字母. 
    如果不存在这样的字符串 s, 请返回一个空字符串 "". 
#solution1406 石子游戏 III stone-game-iii Hard
    Alice 和 Bob 用几堆石子在做游戏. 几堆石子排成一行, 每堆石子都对应一个得分, 由数组 stoneValue 给出. 
    Alice 和 Bob 轮流取石子, Alice 总是先开始. 在每个玩家的回合中, 该玩家可以拿走剩下石子中的的前 1、2 或 3 堆石子, 比赛一直持续到所有石头都被拿走. 
    每个玩家的最终得分为他所拿到的每堆石子的对应得分之和. 每个玩家的初始分数都是 0, 比赛的目标是决出最高分, 得分最高的选手将会赢得比赛, 比赛也可能会出现平局. 
    假设 Alice 和 Bob 都采取 最优策略, 如果 Alice 赢了就返回 "Alice", Bob 赢了就返回 "Bob", 平局(分数相同)返回 "Tie", 
#solution_m_01_06 字符串压缩 compress-string-lcci Easy
    字符串压缩.利用字符重复出现的次数,编写一种方法,实现基本的字符串压缩功能.比如,字符串aabcccccaaa会变为a2b1c5a3.
    若"压缩"后的字符串没有变短,则返回原先的字符串.你可以假设字符串中只包含大小写英文字母(a至z).
#solution_m_01_07 旋转矩阵 rotate-matrix-lcci Medium
    给你一幅由 N × N 矩阵表示的图像, 其中每个像素的大小为 4 字节. 请你设计一种算法, 将图像旋转 90 度. 
    不占用额外内存空间能否做到? 
#solution_m_13_00 机器人的运动范围 ji-qi-ren-de-yun-dong-fan-wei-lcof Medium
    地上有一个m行n列的方格, 从坐标 [0,0] 到坐标 [m-1,n-1]. 一个机器人从坐标 [0, 0] 的格子开始移动, 
    它每次可以向左、右、上、下移动一格(不能移动到方格外), 也不能进入行坐标和列坐标的数位之和大于k的格子. 
    例如, 当k为18时, 机器人能够进入方格 [35, 37] , 因为3+5+3+7=18. 但它不能进入方格 [35, 38], 因为3+5+3+8=19. 请问该机器人能够到达多少个格子? 
#solution_m_16_03 交点 intersection-lcci Hard
    给定两条线段（表示为起点start = {X1, Y1}和终点end = {X2, Y2}）, 如果它们有交点, 请计算其交点, 没有交点则返回空值. 
    要求浮点型误差不超过10^-6. 若有多个交点（线段重叠）则返回 X 值最小的点, X 坐标相同则返回 Y 值最小的点. 
#solution_m_16_25 LRU缓存 lru-cache-lcci Medium
    设计和构建一个"最近最少使用"缓存,该缓存会删除最近最少使用的项目.缓存应该从键映射到值(允许你插入和检索特定键对应的值),
    并在初始化时指定最大容量.当缓存被填满时,它应该删除最近最少使用的项目.
    它应该支持以下操作: 获取数据 get 和 写入数据 put,
    获取数据 get(key) - 如果密钥 (key) 存在于缓存中,则获取密钥的值(总是正数),否则返回 -1.
    写入数据 put(key, value) - 如果密钥不存在,则写入其数据值.当缓存容量达到上限时,它应该在写入新数据之前删除最近最少使用的数据值,从而为新的数据值留出空间.
#solution_m_16_26 计算器 calculator-lcci Medium [= solution0227]
    给定一个包含正整数、加(+)、减(-)、乘(*)、除(/)的算数表达式(括号除外),计算其结果.
    表达式仅包含非负整数,+, -,*,/ 四种运算符和空格 . 整数除法仅保留整数部分.
#solution_m_17_08 马戏团人塔 circus-tower-lcci Medium
    有个马戏团正在设计叠罗汉的表演节目, 一个人要站在另一人的肩膀上. 出于实际和美观的考虑, 在上面的人要比下面的人矮一点且轻一点. 
    已知马戏团每个人的身高和体重, 请编写代码计算叠罗汉最多能叠几个人. 
#solution_m_17_16 按摩师 the-masseuse-lcci Easy
    一个有名的按摩师会收到源源不断的预约请求, 每个预约都可以选择接或不接. 在每次预约服务之间要有休息时间, 因此她不能接受相邻的预约. 
    给定一个预约请求序列, 替按摩师找到最优的预约集合(总预约时间最长), 返回总的分钟数. 
#solution_m_40_00 最小的k个数 zui-xiao-de-kge-shu-lcof Easy
    输入整数数组 arr,找出其中最小的 k 个数.例如,输入4、5、1、6、2、7、3、8这8个数字,则最小的4个数字是1、2、3、4.
#solution_m_62_00 圆圈中最后剩下的数字 yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof Easy
    0,1,,n-1这n个数字排成一个圆圈, 从数字0开始, 每次从这个圆圈里删除第m个数字. 求出这个圆圈里剩下的最后一个数字. 
    例如, 0、1、2、3、4这5个数字组成一个圆圈, 从数字0开始每次删除第3个数字, 则删除的前4个数字依次是2、0、4、1, 因此最后剩下的数字是3. 
#solution_m_63_00 股票的最大利润 gu-piao-de-zui-da-li-run-lcof Medium [= solution0121]
    假设把某股票的价格按照时间先后顺序存储在数组中, 请问买卖该股票一次可能获得的最大利润是多少? 
