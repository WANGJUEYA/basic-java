#solution0001 两数之和 two-sum Easy 
    给定一个整数数组 nums 和一个目标值 target,请你在该数组中找出和为目标值的那两个整数,并返回他们的数组下标.
    你可以假设每种输入只会对应一个答案.但是,你不能重复利用这个数组中同样的元素.
#solution0002 两数相加 add-two-numbers Medium
    给出两个非空的链表用来表示两个非负的整数.其中,它们各自的位数是按照逆序的方式存储的,并且它们的每个节点只能存储一位数字.
    如果,我们将这两个数相加起来,则会返回一个新的链表来表示它们的和.
    您可以假设除了数字0之外,这两个数都不会以0开头.
#solution0003 无重复字符的最长子串 longest-substring-without-repeating-characters Medium
    给定一个字符串,请你找出其中不含有重复字符的最长子串的长度.
#solution0004 寻找两个有序数组的中位数 median-of-two-sorted-arrays Hard
    给定两个大小为 m 和 n 的有序数组 nums1 和 nums2.
    请你找出这两个有序数组的中位数,并且要求算法的时间复杂度为 O(log(m + n)).
    你可以假设 nums1 和 nums2 不会同时为空.
#solution0005 最长回文子串 longest-palindromic-substring Medium
    给定一个字符串 s,找到 s 中最长的回文子串.你可以假设 s 的最大长度为 1000.
#solution0009  回文数 palindrome-number Easy
    判断一个整数是否是回文数.回文数是指正序(从左向右)和倒序(从右向左)读都是一样的整数.
#solution0015 三数之和 3sum Medium
    给定一个包含 n 个整数的数组 nums,判断 nums 中是否存在三个元素 a,b,c ,使得 a + b + c = 0?找出所有满足条件且不重复的三元组.
    注意: 答案中不可以包含重复的三元组.
#solution0017 电话号码的字母组合 letter-combinations-of-a-phone-number Medium
    给定一个仅包含数字 2-9 的字符串,返回所有它能表示的字母组合.
    给出数字到字母的映射如下(与电话按键相同).注意 1 不对应任何字母.
#solution0049 字母异位词分组 group-anagrams Medium
    给定一个字符串数组,将字母异位词组合在一起.字母异位词指字母相同,但排列不同的字符串.
#solution0070 爬楼梯 climbing-stairs Easy
    假设你正在爬楼梯.需要 n 阶你才能到达楼顶.
    每次你可以爬 1 或 2 个台阶.你有多少种不同的方法可以爬到楼顶呢？
    注意:给定 n 是一个正整数.
#solution0083 删除排序链表中的重复元素 remove-duplicates-from-sorted-list Easy
    给定一个排序链表,删除所有重复的元素,使得每个元素只出现一次.
#solution0168  Excel表列名称 excel-sheet-column-title Easy
    给定一个正整数,返回它在 Excel 表中相对应的列名称.
#solution0169 多数元素 majority-element Easy
    给定一个大小为 n 的数组,找到其中的多数元素.多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素.
    你可以假设数组是非空的,并且给定的数组总是存在多数元素.
#solution0200 岛屿数量 number-of-islands Medium
    给定一个由 '1'(陆地)和 '0'(水)组成的的二维网格,计算岛屿的数量.一个岛被水包围,并且它是通过水平方向或垂直方向上相邻的陆地连接而成的.你可以假设网格的四个边均被水包围.
#solution0223 矩形面积 rectangle-area Medium
    在二维平面上计算出两个由直线构成的矩形重叠后形成的总面积.
    每个矩形由其左下顶点和右上顶点坐标表示,如图所示.
#solution0300 最长上升子序列 longest-increasing-subsequence Medium
    给定一个无序的整数数组,找到其中最长上升子序列的长度.
#solution0407 接雨水 II trapping-rain-water-ii Hard
    给定一个 m x n 的矩阵,其中的值均为正整数,代表二维高度图每个单元的高度,请计算图中形状最多能接多少体积的雨水.
#solution0419 甲板上的战舰 battleships-in-a-board Medium
    给定一个二维的甲板, 请计算其中有多少艘战舰. 战舰用 'X'表示,空位用 '.'表示. 你需要遵守以下规则:
    给你一个有效的甲板,仅由战舰或者空位组成.
    战舰只能水平或者垂直放置.换句话说,战舰只能由 1xN (1 行, N 列)组成,或者 Nx1 (N 行, 1 列)组成,其中N可以是任意大小.
    两艘战舰之间至少有一个水平或垂直的空位分隔 - 即没有相邻的战舰.
#solution0626 换座位 exchange-seats Medium
    小美是一所中学的信息科技老师,她有一张 seat 座位表,平时用来储存学生名字和与他们相对应的座位 id.
    其中纵列的 id 是连续递增的
    小美想改变相邻俩学生的座位.
    你能不能帮她写一个 SQL query 来输出小美想要的结果呢?
#solution0673 最长递增子序列的个数 number-of-longest-increasing-subsequence Medium
    给定一个未排序的整数数组,找到最长递增子序列的个数.
#solution0677 键值映射 map-sum-pairs Medium
    实现一个 MapSum 类里的两个方法,insert 和 sum.
    对于方法 insert,你将得到一对(字符串,整数)的键值对.字符串表示键,整数表示值.如果键已经存在,那么原来的键值对将被替代成新的键值对.
    对于方法 sum,你将得到一个表示前缀的字符串,你需要返回所有以该前缀开头的键的值的总和.
#solution0695 岛屿的最大面积 max-area-of-island Medium
    给定一个包含了一些 0 和 1的非空二维数组 grid , 一个 岛屿 是由四个方向 (水平或垂直) 的 1 (代表土地) 构成的组合.你可以假设二维矩阵的四个边缘都被水包围着.
    找到给定的二维数组中最大的岛屿面积.(如果没有岛屿,则返回面积为0.)
#solution0860 柠檬水找零 lemonade-change Easy
    在柠檬水摊上,每一杯柠檬水的售价为 5 美元.
    顾客排队购买你的产品,(按账单 bills 支付的顺序)一次购买一杯.
    每位顾客只买一杯柠檬水,然后向你付 5 美元,10 美元或 20 美元.你必须给每个顾客正确找零,也就是说净交易是每位顾客向你支付 5 美元.
    注意,一开始你手头没有任何零钱.
    如果你能给每位顾客正确找零,返回 true ,否则返回 false .
#solution0865 具有所有最深结点的最小子树 smallest-subtree-with-all-the-deepest-nodes Medium
    给定一个根为 root 的二叉树,每个结点的深度是它到根的最短距离.
    如果一个结点在整个树的任意结点之间具有最大的深度,则该结点是最深的.
    一个结点的子树是该结点加上它的所有后代的集合.
    返回能满足"以该结点为根的子树中包含所有最深的结点"这一条件的具有最大深度的结点.
#solution1071 字符串的最大公因子 greatest-common-divisor-of-strings Easy
    对于字符串 S 和 T,只有在 S = T + ... + T(T 与自身连接 1 次或多次)时,我们才认定 "T 能除尽 S".
    返回最长字符串 X,要求满足 X 能除尽 str1 且 X 能除尽 str2.
#solution5179 将二叉搜索树变平衡 balance-a-binary-search-tree Medium
    给你一棵二叉搜索树,请你返回一棵 平衡后 的二叉搜索树,新生成的树应该与原来的树有着相同的节点值.
    如果一棵二叉搜索树中,每个节点的两棵子树高度差不超过 1 ,我们就称这棵二叉搜索树是 平衡的 .
    如果有多种构造方法,请你返回任意一种.
#solution5356 矩阵中的幸运数 lucky-numbers-in-a-matrix Easy
    给你一个 m * n 的矩阵,矩阵中的数字 各不相同 .请你按 任意 顺序返回矩阵中的所有幸运数.
    幸运数是指矩阵中满足同时下列两个条件的元素:
    在同一行的所有元素中最小
    在同一列的所有元素中最大
#solution5357 设计一个支持增量操作的栈 design-a-stack-with-increment-operation Medium
    请你设计一个支持下述操作的栈.
    实现自定义栈类 CustomStack :
    CustomStack(int maxSize):用 maxSize 初始化对象,maxSize 是栈中最多能容纳的元素数量,栈在增长到 maxSize 之后则不支持 push 操作.
    void push(int x):如果栈还未增长到 maxSize ,就将 x 添加到栈顶.
    int pop():返回栈顶的值,或栈为空时返回 -1 .
    void inc(int k, int val):栈底的 k 个元素的值都增加 val .如果栈中元素总数小于 k ,则栈中的所有元素都增加 val .
#solution5359 最大的团队表现值 maximum-performance-of-a-team Hard
    公司有编号为 1 到 n 的 n 个工程师,给你两个数组 speed 和 efficiency ,其中 speed[i] 和 efficiency[i] 分别代表第 i 位工程师的速度和效率.请你返回由最多 k 个工程师组成的 ​​​​​​最大团队表现值 ,由于答案可能很大,请你返回结果对 10^9 + 7 取余后的结果.
    团队表现值 的定义为:一个团队中「所有工程师速度的和」乘以他们「效率值中的最小值」.
#solution_m_01_06 字符串压缩 compress-string-lcci Easy
    字符串压缩.利用字符重复出现的次数,编写一种方法,实现基本的字符串压缩功能.比如,字符串aabcccccaaa会变为a2b1c5a3.若"压缩"后的字符串没有变短,则返回原先的字符串.你可以假设字符串中只包含大小写英文字母(a至z).
#solution_m_16_25 LRU缓存 lru-cache-lcci Medium
    设计和构建一个"最近最少使用"缓存,该缓存会删除最近最少使用的项目.缓存应该从键映射到值(允许你插入和检索特定键对应的值),并在初始化时指定最大容量.当缓存被填满时,它应该删除最近最少使用的项目.
    它应该支持以下操作: 获取数据 get 和 写入数据 put .
    获取数据 get(key) - 如果密钥 (key) 存在于缓存中,则获取密钥的值(总是正数),否则返回 -1.
    写入数据 put(key, value) - 如果密钥不存在,则写入其数据值.当缓存容量达到上限时,它应该在写入新数据之前删除最近最少使用的数据值,从而为新的数据值留出空间.
